#!/usr/bin/env bash

kTHIS_HOMEPAGE='https://github.com/mklement0/ttab'
kTHIS_NAME=${BASH_SOURCE##*/}
kTHIS_VERSION='v0.2.0' # NOTE: This assignment is automatically updated by `make version VER=<newVer>` - DO keep the 'v' prefix.

unset CDPATH  # To prevent unexpected `cd` behavior.

# --- Begin: STANDARD HELPER FUNCTIONS

die() { echo "$kTHIS_NAME: ERROR: ${1:-"ABORTING due to unexpected error."}" 1>&2; exit ${2:-1}; }
dieSyntax() { echo "$kTHIS_NAME: ARGUMENT ERROR: ${1:-"Invalid argument(s) specified."} Use -h for help." 1>&2; exit 2; }

# SYNOPSIS
#   openUrl <url>
# DESCRIPTION
#   Opens the specified URL in the system's default browser.
openUrl() {
  local url=$1
  open "$url" || { echo "Cannot locate or failed to open default browser; please go to '$url' manually." >&2; return 1; }
}

# Prints the embedded Markdown-formatted man-page source to stdout.
printManPageSource() {
  sed -n -e $'/^: <<\'EOF_MAN_PAGE\'/,/^EOF_MAN_PAGE/ { s///; t\np;}' "$BASH_SOURCE"
}

# Opens the man page, if installed; otherwise, tries to display the embedded Markdown-formatted man-page source; if all else fails: tries to display the man page online.
openManPage() {
  local pager embeddedText 
  if ! man 1 "$kTHIS_NAME" 2>/dev/null; then
    # 2nd attempt: if present, display the embedded Markdown-formatted man-page source
    embeddedText=$(printManPageSource)
    if [[ -n $embeddedText ]]; then
      pager='more'
      command -v less &>/dev/null && pager='less' # see if the non-standard `less` is available, because it's preferable to the POSIX utility `more`
      printf '%s\n' "$embeddedText" | "$pager"
    else # 3rd attempt: open the the man page on the utility's website
      openUrl "${kTHIS_HOMEPAGE}/doc/${kTHIS_NAME}.md"
    fi
  fi  
}

# Prints the contents of the synopsis chapter of the embedded Markdown-formatted man-page source.
printUsage() {
  local embeddedText
  # Extract usage information from the SYNOPSIS chapter of the embedded Markdown-formatted man-page source.
  embeddedText=$(sed -n -e $'/^: <<\'EOF_MAN_PAGE\'/,/^EOF_MAN_PAGE/!d; /SYNOPSIS$/,/^[^ ]/{ s///; t\np; }' "$BASH_SOURCE")
  if [[ -n $embeddedText ]]; then
    # Print extracted synopsis chapter - remove backticks for uncluttered display.
    printf '%s\n' "$embeddedText" | tr -d '`'
  else # No SYNOPIS chapter found; fall back to displaying the man page.
    echo "WARNING: usage information not found; opening man page instead." >&2
    openManPage
  fi
}

# --- End: STANDARD HELPER FUNCTIONS

# ---  PROCESS STANDARD, OUTPUT-INFO-THEN-EXIT OPTIONS.
case $1 in
  --version)
    # Output version number and exit, if requested.
    echo "$kTHIS_NAME $kTHIS_VERSION"$'\nFor license information and more, visit '"$kTHIS_HOMEPAGE"; exit 0
    ;;
  -h|--help)
    # Print usage information and exit.
    printUsage; exit
    ;;
  --man)
    # Display the manual page and exit, falling back to printing the embedded man-page source.
    openManPage; exit
    ;;
  --man-embedded) # private option, used by `make update-doc`
    # Print raw, embedded Markdown-formatted man-page source and exit
    printManPageSource; exit
    ;;
  --home)
    # Open the home page and exit.
    openUrl "$kTHIS_HOMEPAGE"; exit
    ;;
esac

# --- MAIN BODY

# Undocumented debugging support: if the very first argument is --dry-run, we print out the synthesized AppleScript rather than executing it.
printScript=0 dryRun=0
{ [[ $1 == '--dry-run' ]] && { dryRun=1; shift; }; } || { [[ $1 == '--print-script' ]] && { printScript=1; shift; }; }

# Parse options
dirAbs=''
tabTitle=''
settingsName=''
inBackground=0
inNewWin=0
while getopts ':wgGs:t:d:' opt; do  # $opt will receive the option *letters* one by one; a trailing : means that an arg. is required, reported in $OPTARG.
  [[ $opt == '?' ]] && dieSyntax "Unknown option: -$OPTARG"
  [[ $opt == ':' ]] && dieSyntax "Option -$OPTARG is missing its argument."
  case "$opt" in
    w)
      inNewWin=1
      ;;
    s)
      settingsName=$OPTARG
      ;;
    t)
      tabTitle=$OPTARG
      ;;
    d)
      dir=$OPTARG
      dirAbs=$(cd -- "$dir" 2>/dev/null && echo "$PWD") || die "No such directory: $dir"
      ;;
    g)
      inBackground=1
      ;;
    G)
      inBackground=2
      ;;
    *) # An unrecognized switch.
      dieSyntax "DESIGN ERROR: unanticipated option: $opt"
      ;;
  esac
done
shift $((OPTIND - 1)) # Skip the already-processed arguments (options).

# All remaining arguments, if any, make up the command to execute in the new tab/window.        

# Clear any variables with names matching those we'll be using below, to be safe.
for n in ${!CMD_*}; do unset $n; done

  # Note: We use *menu-based GUI scripting* rather than *sending keystrokes via CMD_NEWTAB_1='tell application "System Events" to keystroke "t" using {command down}'
  #       !! We try to be locale-independent, so we don't use menu-item command *names*; this requires us to make the following ASSUMPTIONS, which we expect to hold in the future:
  #             - the new *window* commands are assumed to be in a *submenu* of the *1st command* ('New Window > ...') of the Shell menu.
  #             - the new *tab* commands are assumed to be in a *submenu* of the *2nd command* ('New Tab > ...') of the Shell menu.
  #       (a) compared to sending a keystroke, this is more robust and predictable; with sending a keystroke, the shell command to execute is *sometimes* sent to the *previous* tab, as the keystroke may not have been processed yet.
  #           In the default case, the GUI scripting finds the command by its keyboard shortcut so as to work locale-independently; it does, however, make the following assumptions (other than the pretty safe assumption that the command is in the 3rd menu from the left, the "Shell" menu in English):
  #       (b) it also allows us to create new tabs *with specific settings*, by finding the menu item by *name* (settings names are locale-*in*dependent, fortunately)
  #           Using this is preferable to trying to apply settings *after* tab creation with `set current settings of selected tab ...`, as the latter only applies *visual* attributes, not *behavioral* (such as what to do when the shell exits)
if (( inNewWin )); then # create the tab in a new window
  if [[ -n $settingsName ]]; then
    CMD_NEWTAB_1="tell application \"System Events\" to tell menu 1 of menu item 1 of menu 1 of menu bar item 3 of menu bar 1 of application process \"Terminal\" to click menu item \"$settingsName\""
    CMD_NEWTAB_2="set newTab to selected tab of front window"
  else
    CMD_NEWTAB_1=''
    CMD_NEWTAB_2='set newTab to do script' # note that running `do script` without arguments (i.e., without a suffix specifying the target window (e.g., 'in front window')) creates a *new* window.
  fi  
  if (( inBackground == 2 )); then # For use with -G: commands for saving and restoring the previous state within Terminal
    CMD_SAVE_ACTIVE_TAB='set prevWin to front window'
    CMD_REACTIVATE_PREV_TAB='set frontmost of prevWin to true' # Note that while  *Terminal.app*'s  windows have a `frontmost` property that allows their activation within the app, most other (all other?) apps' windows do not.
  fi
else # Create the new tab in the current window (unlike `do shell script` with no target for creating a new *window*, `do shell script in front window` simply executes in the *current* tab, and there's no direct way to target a new one).
  if [[ -n $settingsName ]]; then
    CMD_NEWTAB_1="tell application \"System Events\" to tell menu 1 of menu item 2 of menu 1 of menu bar item 3 of menu bar 1 of application process \"Terminal\" to click menu item \"$settingsName\""
  else
    CMD_NEWTAB_1='tell application "System Events" to tell menu 1 of menu item 2 of menu 1 of menu bar item 3 of menu bar 1 of application process "Terminal" to click (first menu item whose value of attribute "AXMenuItemCmdChar" is "T" and value of attribute "AXMenuItemCmdModifiers" is 0)'
  fi
  CMD_NEWTAB_2='set newTab to selected tab of front window'
  if (( inBackground == 2 )); then # For use with -G: commands for saving and restoring the previous state within Terminal
    CMD_SAVE_ACTIVE_TAB='set prevTab to (selected tab of front window)'
    CMD_REACTIVATE_PREV_TAB='set selected of prevTab to true'
  fi
fi

    # For use with -g and -G: commands for saving and restoring the previous application
if (( inBackground )); then
  CMD_SAVE_ACTIVE_APPNAME='set prevAppName to name of application (path to frontmost application as text)'
  CMD_REACTIVATE_PREV_APP='activate application prevAppName'
  # !! With -g and -G, sadly, we must, unfortunately, briefly activate Terminal in order for the menu-command GUI scripting to work correctly, then reactivate the previously active application.
  # !! On 10.10+, activate is no longer *synchronous*, so we must wait until Terminal is truly activated (frontmost)
  CMD_ACTIVATE='activate
  repeat until frontmost
      delay 0.1
  end repeat'
fi

  # Optional commands that are only used if the relevant options were specified.
quotedShellCmds=''
if (( $# )); then # Shell command(s) specified.
  if [[ -z $tabTitle ]]; then
        # Use the command's first token as the tab title.
    tabTitle=$1
    case "$tabTitle" in
        exec|eval) # Use following token instead, if the 1st one is 'eval' or 'exec'.
            tabTitle=$(echo "$2" | awk '{ print $1 }') 
            ;;
        cd) # Use last path component of following token instead, if the 1st one is 'cd'
            tabTitle=$(basename "$2")
            ;;
    esac
  fi
      # The tricky part is to quote the command tokens properly when passing them to AppleScript:
      # Quote all parameters (as needed) using printf '%q' - this will perform backslash-escaping.
      # This will allow us to not have to deal with double quotes inside the double-quoted string that will be passed to `do script`.
  quotedShellCmds=$(printf '%q ' "$@")  # note: we'll end up with a trailing space, but that's benign.
fi

  # If no directory was specified, we explicitly use the *current* working directory, 
  # if we're called from *inside a script*.
  # Rationale: Terminal.app only knows the working directory of the *top-level* shell running in each tab (as it defines an aux. function,
  # update_terminal_cwd(), that is called via $PROMPT_COMMAND every time the prompt is displayed).
  # Thus, when this script is invoked inside another script, it is the *top-level* shell's working directory that is invariably used by
  # Terminal, even if the invoking script has changed the working directory. Since this is counter-intuitive, we compensate here
  # by explicitly setting the working directory to the invoking script's with a prepended 'cd' command.
  # $SHLVL tells us the nesting level of the current shell:
  # 1 == top-level shell; since this script itself runs in a subshell (2, if invoked directly from the top-level shell), we can safely assume 
  # that another *script* has invoked us, if $SHLVL >= 3.
  # Furthermore, we want to exhibit the same behavior when creating a tab in a *new* window, whereas Terminal defaults to the home directory
  # in that case - thus, regardless of $SHLVL, if -w is specified, we always use an explicit 'cd' command.
if [[ -z $dirAbs && ($inNewWin -eq 1 || $SHLVL -ge 3) ]]; then
  dirAbs=$PWD
fi

  # Prepend the 'cd' command, if specified or needed.
if [[ -n $dirAbs ]]; then
  quotedCdCmd=$(printf 'cd %q' "$dirAbs")
  if [[ -n $quotedShellCmds ]]; then
    quotedShellCmds="$quotedCdCmd; $quotedShellCmds"
  else
    quotedShellCmds=$quotedCdCmd
  fi
fi

  # Synthesize the full shell command.
if [[ -n $quotedShellCmds ]]; then
  # Pass the commands as a single AppleScript string, of necessity double-quoted.
  # For the benefit of AppleScript
  #  - embedded backslashes must be escaped by doubling them
  #  - embedded doubleq quotes must be backlash-escaped
  quotedShellCmdsForAppleScript=${quotedShellCmds//\\/\\\\}
  quotedShellCmdsForAppleScript=${quotedShellCmdsForAppleScript//\"/\\\"}
  CMD_CUSTOM="do script \"${quotedShellCmdsForAppleScript}\" in newTab"
  # CMD_CUSTOM="do script \"${quotedShellCmds//\\/\\\\}\" in newTab"
fi

if [[ -n $tabTitle ]]; then
  CMD_TITLE="set custom title of newTab to \"$tabTitle\""
fi

# Now, synthesize the entire AppleScript
# !! At least on 10.10, the commands to save the active application and to reactivate it later must be OUTSIDE of the tell application "Terminal" block to work.
read -d '' -r script <<EOF
$CMD_SAVE_ACTIVE_APPNAME
tell application "Terminal"
  $CMD_SAVE_ACTIVE_TAB
  $CMD_ACTIVATE
  $CMD_NEWTAB_1
  $CMD_NEWTAB_2
  $CMD_TITLE
  $CMD_CUSTOM
  $CMD_REACTIVATE_PREV_TAB
end tell
$CMD_REACTIVATE_PREV_APP
return
EOF

(( dryRun || printScript )) && { printf %s "$script"; (( dryRun )) && exit; }

# Execute the AppleScript
osascript <<<"$script"

####
# MAN PAGE MARKDOWN SOURCE
#  - Place a Markdown-formatted version of the man page for this script
#    below the : <<'EOF_MAN_PAGE' line below.
#  - The entire rest of this script
#    is assumed to be the Markdown document.
#  Markdown formatting:
#   - Append the manual-section number directly to the CLI name in the first heading; e.g.
#      # foo(1) - does bar
#   - Use 1-space indentation for plain-text rendering; 4-space indentation, as usual, for code blocks.
#   - The contents of the SYNOPSIS chapter is extracted when -h/--help is invoked.
#     Use 4-space indentation without markup for both the syntax line and the
#     block of brief option descriptions; represent option-arguments and operands
#     in angle brackets; e.g., '<foo>'
#  - To support plain-text rendering in the terminal, limit lines to 80 chars.,
#    and, for similar rendering as HTML, *end every line with 2 trailing spaces*.
#  - Options list:
#    - End every list item (bullet point) itself with 2 trailing spaces so
#      that it renders on its own line.
#    - To associate more than 1 paragraph with a list item, use the following TRICK:
#      To produce an empty line while still keeping the text attached to the list item,
#      use '&nbsp;<space><space>', though note that that introduces noise in plain-text rendering.
#    - To follow the last list item with regular paragraphs, leave *2* empty lines
#      in between.
#   Character-styling markup in `man` view:
#      `...` and **...** render as bolded (red) text
#      _..._ and *...* render as word-individually underlined text
####
: <<'EOF_MAN_PAGE' # DO NOT ALTER THIS LINE.
# ttab(1) - open a new Terminal.app tab or window

## SYNOPSIS
 Opens a new terminal tab or window in OS X's Terminal.app application.

    ttab [-w] [-s <settings>] [-t <title>] [-g|-G] [-d <dir>] [<cmd> [<arg>...]]

    -w                  open new tab in new terminal window
    -s <settings>       assign a Terminal.app settings set (profile)
    -t <title>          specify title for new tab
    -g                  create tab in background (do not activate Terminal.app)
    -G                  create tab in background and do not activate new tab
    -d <dir>            specify working directory
    <cmd> [<arg>...]    command to execute in the new tab

 Standard options: `--help`, `--man`, `--version`, `--home`

## DESCRIPTION
 `ttab` opens a new Terminal.app tab with a variety of options, including  
 executing a command in the new tab, assigning a title and working directory,  
 and opening the tab in a new window.

 IMPORTANT: **Terminal.app must be allowed assistive access** in order for this  
 utility to work, which requires one-time authorization with administrative  
 privileges. If you get error messages instead of being prompted, authorize  
 Terminal.app via System Preferences > Security & Privacy > Privacy >  
 Accessibility.

 The new tab will run a login shell (i.e., load the user's shell profile)  
 and by default inherit the working directory from the parent shell.

 When specifying a command to execute in the new tab, quoted parameters are  
 handled properly and there's no need to quote the command as a whole,  
 provided it is a *single* command.  
 Prefix such a single command with `exec` to exit the shell after the command  
 terminates. If the tab's settings are configured to close tabs on termination  
 of the shell, the tab will close automatically.

 To specify *multiple* commands, use `eval` followed by a single, quoted  
 string containing the entire shell command line to execute; in the simplest  
 case, enclose the string in single-quotes and use ';' to separate commands.  
 Use `exit` as the last command to automatically close the tab when the  
 command terminates, assuming the tab's settings are configured to close the  
 tab on termination of the shell.  
 Precede `exit` with `read -rsn 1` to wait for a keystroke first.

## OPTIONS
 * `-w`  
    creates the new tab in a new window rather than in Terminal's front  
    window.

 * `-s <settings>`  
    specifies the settings (profiles) to apply to the new tab, as  
    defined in Terminal.app's Preferences > Profiles, such as 'Grass';  
    settings determine the appearance and behavior of the new tab; name  
    matching is case-insensitive.

 * `-t <title>`   
    specifies a custom title to assign to the new tab; otherwise, if a   
    command is specified, its first token will become the new tab's title.

 * `-d <dir>`  
    explicitly specifies a working directory for the new tab; by default, the  
    invoking shell's working directory is inherited (even if `-w` is also  
    specified).

 * `-g`  
    (back*g*round) causes Terminal not to activate, if it isn't the frontmost  
    application); within Terminal, however, the new tab will become active  
    active tab; useful in scripts that launch other applications and  
    don't want Terminal to steal focus later.

 * `-G`  
    causes Terminal not to activate *and* the active element within Terminal  
    not to change; i.e., the active window and tab stay the same. If Terminal  
    happens to be frontmost, the new tab will effectively open in the  
    background.


 NOTE: With `-g` or `-G` specified, for technical reasons, Terminal / the new  
       tab will still activate *briefly, temporarily* in most scenarios.

## STANDARD OPTIONS
 All standard options provide information only.

 * `-h, --help`  
    Prints the contents of the synopsis chapter to stdout for quick reference.

 * `--man`  
    Displays this manual page, which is a helpful alternative to using `man`, 
    if the manual page isn't installed.

 * `--version`  
    Prints version information.
    
 * `--home`  
    Opens this utility's home page in the system's default web browser.

## LICENSE
 For license information and more, visit this utility's home page by running  
 `ttab --home`.

## EXAMPLES
    # Open new tab in current terminal window:
    ttab

    # Open new tab in new terminal window:
    ttab -w

    # Open new tab with title 'Green' using settings 'Grass':
    ttab -t Green -s Grass  

    # Open new tab and execute a command in it:
    ttab ls -l "$HOME/Library/Application Support"

    # Open new tab with specified working dir. and execute a command in it:
    ttab -d "$HOME/Library/Application Support" ls -l
    
    # Execute a command and exit.
    # If configured via settings, also close the tab.
    ttab exec /path/to/someprogram arg1 arg2
    
    # Pass a multi-command string via 'eval', wait for a keystroke, then exit.
    ttab eval 'ls "$HOME/Library/Application Support";
                                echo Press any key to exit; read -rsn 1; exit'
EOF_MAN_PAGE
